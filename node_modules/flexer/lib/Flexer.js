// Generated by CoffeeScript 1.10.0
(function() {
  var Flexer, computeLayout, fn, j, layoutProp, len, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  computeLayout = require("css-layout");

  Flexer = (function(superClass) {
    extend(Flexer, superClass);

    Flexer.layoutProps = ["fixedWidth", "fixedHeight", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "right", "top", "bottom", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom", "padding", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth", "flexDirection", "justifyContent", "alignItems", "alignSelf", "flex", "flexWrap", "position"];

    Flexer.prototype.curve = void 0;

    function Flexer(layer) {
      var property;
      this.layer = layer;
      this._drawIfNeeded = bind(this._drawIfNeeded, this);
      this._setNeedsUpdate = bind(this._setNeedsUpdate, this);
      this._updateTree = bind(this._updateTree, this);
      this._didResize = bind(this._didResize, this);
      this.layer.on("change:subLayers", this._updateTree);
      Framer.Loop.on("update", this._drawIfNeeded);
      this.layer._context.domEventManager.wrap(window).addEventListener("resize", this._didResize);
      this._layoutNode = {
        style: {},
        children: []
      };
      for (property in Flexer.layoutProps) {
        if (this.layer[property]) {
          this._layoutNode.style[this._getLayoutProperty(property)] = this.layer[property];
        }
      }
    }

    Flexer.prototype._didResize = function() {
      if (!this.layer.superLayer) {
        return this._setNeedsUpdate();
      }
    };

    Flexer.prototype._getLayoutProperty = function(property) {
      var cssLayoutProperty;
      cssLayoutProperty = property;
      if (cssLayoutProperty === "fixedWidth") {
        cssLayoutProperty = "width";
      }
      if (cssLayoutProperty === "fixedHeight") {
        cssLayoutProperty = "height";
      }
      return cssLayoutProperty;
    };

    Flexer.prototype.updateProperty = function(property, value) {
      if (property) {
        this._layoutNode.style[this._getLayoutProperty(property)] = value;
      }
      return this._setNeedsUpdate();
    };

    Flexer.prototype._updateTree = function(layersChanged) {
      var j, k, layerAdded, layerRemoved, len, len1, ref, ref1;
      ref = layersChanged.added;
      for (j = 0, len = ref.length; j < len; j++) {
        layerAdded = ref[j];
        this._layoutNode.children.push(layerAdded.layout._layoutNode);
      }
      ref1 = layersChanged.removed;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        layerRemoved = ref1[k];
        this._layoutNode.children.splice(_layoutNode.indexOf(layerRemoved.layout._layoutNode), 1);
      }
      return this._setNeedsUpdate();
    };

    Flexer.prototype._setNeedsUpdate = function() {
      var rootLayer;
      rootLayer = this.layer;
      while (rootLayer.superLayer) {
        rootLayer = rootLayer.superLayer;
      }
      return rootLayer.layout.needsUpdate = true;
    };

    Flexer.prototype._drawIfNeeded = function() {
      var newTree, rootLayoutNode;
      if (!this.layer.superLayer && this.needsUpdate) {
        this.needsUpdate = false;
        rootLayoutNode = {
          style: {
            width: Screen.width,
            height: Screen.height
          },
          children: [this._layoutNode]
        };
        newTree = Framer._.cloneDeep(rootLayoutNode);
        computeLayout(newTree);
        return this._updateLayer(newTree.children[0]);
      }
    };

    Flexer.prototype._updateLayer = function(computedTree) {
      var frame, i, j, len, ref, results, subLayer;
      if (computedTree.shouldUpdate) {
        if (!this.curve) {
          frame = {
            x: computedTree.layout.left,
            y: computedTree.layout.top,
            width: computedTree.layout.width,
            height: computedTree.layout.height
          };
          this.layer.frame = frame;
        } else {
          this.layer.animate({
            properties: {
              x: computedTree.layout.left,
              y: computedTree.layout.top,
              width: computedTree.layout.width,
              height: computedTree.layout.height
            },
            curve: this.curve
          });
        }
      }
      ref = this.layer.subLayers;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        subLayer = ref[i];
        if (computedTree.children && computedTree.children.length > i) {
          results.push(subLayer.layout._updateLayer(computedTree.children[i]));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return Flexer;

  })(Framer.EventEmitter);

  Layer.define("layout", {
    get: function() {
      if (this._layout == null) {
        this._layout = new Flexer(this);
      }
      return this._layout;
    }
  });

  ref = Flexer.layoutProps;
  fn = (function(_this) {
    return function(layoutProp) {
      return Layer.define(layoutProp, {
        "default": void 0,
        get: function() {
          return this._getPropertyValue(layoutProp);
        },
        set: function(value) {
          this._setPropertyValue(layoutProp, value);
          return this.layout.updateProperty(layoutProp, value);
        }
      });
    };
  })(this);
  for (j = 0, len = ref.length; j < len; j++) {
    layoutProp = ref[j];
    fn(layoutProp);
  }

  module.exports = Flexer;

}).call(this);
